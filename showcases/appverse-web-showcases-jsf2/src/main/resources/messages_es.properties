#Copyright (c) 2012 GFT Appverse, S.L., Sociedad Unipersonal.
#
# This Source Code Form is subject to the terms of the Mozilla Public 
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/. 
#
# Redistribution and use in source and binary forms, with or without modification, 
# are permitted provided that the conditions of the Mozilla Public License v2.0 
# are met.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. EXCEPT IN CASE OF WILLFUL MISCONDUCT OR GROSS NEGLIGENCE, IN NO EVENT
# SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) 
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
# POSSIBILITY OF SUCH DAMAGE.

# ==============================================================================
# Component Errors
# ==============================================================================
javax.faces.component.UIInput.CONVERSION=Ha ocurrido un error de conversi\u00c3\u00b3n
javax.faces.component.UIInput.REQUIRED=Este campo es obligatorio
javax.faces.component.UIInput.UPDATE=Ha ocurrido un error enviando los datos
javax.faces.component.UISelectOne.INVALID=Valor inv\u00c3\u00a1lido
javax.faces.component.UISelectMany.INVALID=Valor inv\u00c3\u00a1lido

# ==============================================================================
# Validator Errors
# ==============================================================================

javax.faces.validator.NOT_IN_RANGE=El valor introducido no est\u00c3\u00a1 dentro del rango esperado: {0} y {1}
javax.faces.validator.DoubleRangeValidator.MAXIMUM=El valor es mayor que el m\u00c3\u00a1ximo admitido: ''{0}''
javax.faces.validator.DoubleRangeValidator.MINIMUM=El valor es menor que el m\u00c3\u00adnimo admitido: ''{0}''
javax.faces.validator.DoubleRangeValidator.NOT_IN_RANGE=El valor introducido no est\u00c3\u00a1 dentro del rango esperado: {0} y {1}
javax.faces.validator.DoubleRangeValidator.TYPE=El valor no es del tipo esperado
javax.faces.validator.LengthValidator.MAXIMUM=El valor es mayor que el m\u00c3\u00a1ximo admitido: ''{0}''
javax.faces.validator.LengthValidator.MINIMUM=El valor es menor que el m\u00c3\u00adnimo admitido: ''{0}''
javax.faces.validator.LongRangeValidator.MAXIMUM=El valor es mayor que el m\u00c3\u00a1ximo admitido: ''{0}''
javax.faces.validator.LongRangeValidator.MINIMUM=El valor es menor que el m\u00c3\u00adnimo admitido: ''{0}''
javax.faces.validator.LongRangeValidator.NOT_IN_RANGE=El valor introducido no est\u00c3\u00a1 dentro del rango esperado: {0} y {1}
javax.faces.validator.LongRangeValidator.TYPE=El valor no es del tipo esperado
javax.faces.converter.DateTimeConverter.DATE=Por favor, introduzca una fecha correcta
javax.faces.converter.DateTimeConverter.DATE_detail=Por favor, introduzca una fecha correcta. Ejemplo: {1}
javax.faces.converter.IntegerConverter.INTEGER=Este campo debe ser num\u00c3\u00a9rico
javax.validation.constraints.Future.message=El campo debe ser una fecha futura

# ==============================================================================
# Calendar
# ==============================================================================

RICH_CALENDAR_APPLY_LABEL=Aplicar
RICH_CALENDAR_TODAY_LABEL=Hoy
RICH_CALENDAR_CLOSE_LABEL=Cerrar
RICH_CALENDAR_OK_LABEL=Aceptar
RICH_CALENDAR_CLEAN_LABEL=Limpiar
RICH_CALENDAR_CANCEL_LABEL=Cancelar

# ==============================================================================
# Internationalization (internationalization.xhtml)
# ==============================================================================

internationalization.language.title = Internacionalizaci\u00c3\u00b3n en JSF2 
internationalization.language.ENGLISH = Ingl\u00c3\u00a9s
internationalization.language.CATALAN = Catal\u00c3\u00a1n
internationalization.language.SPANISH = Castellano
internationalization.firstFacet = Internationaliza tu aplicaci\u00c3\u00b3n JSF2
internationalization.definition1 = JSF2 (JSF) como muchos productos basados en Java, est\u00c3\u00a1 dise\u00c3\u00b1ado para que la internacionalizaci\u00c3\u00b3n sea f\u00c3\u00a1cil. Una de las caracter\u00c3\u00adsticas principales son los Message Bundles. Message Bundles son simples ficheros de texto (property files) compuestos de pares clave/valor. Son muy f\u00c3\u00a1ciles de usar. Lo m\u00c3\u00a1s importante es tener un fichero por cada idioma soportado, por ejemplo uno en Ingl\u00c3\u00a9s, otro en Catal\u00c3\u00a1n, Catellano o cualquier otro lenguaje. Se carga un MessageBundle con el locale actual y se obtienen los valores desde ficheros. Puedes a\u00c3\u00b1adir ficheros para otros lenguajes en cualquier momento. Para internacionalizar tu aplicaci\u00c3\u00b3n JSF2 necesitar\u00c3\u00a1s seguir los siguientes pasos. 
internationalization.secondFacet = Declara tu fichero de recursos (properties files)
internationalization.definition2 = Puedes declarar ficheros de recursos de dos maneras.
internationalization.item1 = La manera m\u00c3\u00a1s sencilla es proporcionar la declaraci\u00c3\u00b3n en tu faces-config.xml como a continuaci\u00c3\u00b3n:
internationalization.item2 = En vez de utilizar una declaraci\u00c3\u00b3n de fichero de recursos, puedes a\u00c3\u00b1adir el elemento f:load-Bundle a cada p\u00c3\u00a1gina SF page que necesite el recurso, as\u00c3\u00ad:
internationalization.definition3 = En ambos casos, los mensajes en los ficheros de recursos son accesibles a trav\u00c3\u00a9s de una variable map con nombre "msg". El fichero de recursos debe acabar con .properties (messages.properties).
 
internationalization.thirdFacet = Declara tu local por defecto y los soportados
internationalization.definition4 = En tu faces-config.xml:

internationalization.fourthFacet = C\u00c3\u00b3mo utilizar un fichero de recursos
internationalization.definition5 = En cualquier fichero .jsf utiliza la variable definida en faces-config.xml o con <f:loadBundle>. La variable aqu\u00c3\u00ad se llama "msg". Dicha variable se ha de utilizar con una clave definida en un fichero de properties. Por ejemplo, para obtener la cadena localizada "name" puedes hacerlo as\u00c3\u00ad:
internationalization.definition6 = Si quieres utilizar cadenas localizadas en tu managed beans:
internationalization.item3 = Obtiene el locale utilizado por tu navegador :
internationalization.item4 = Carga del fichero de recursos asociado con este locale, utilizando el path completo y el base name (tambi\u00c3\u00a9n podr\u00c3\u00ada utilizarse uno relativo):
internationalization.item5 = Puedes obtener cualquier valor utilizando su clave en el fichero de properties :

internationalization.fifthFacet = Crea tu Locale Bean
internationalization.definition7 = Puedes utilizar cadenas localizadas e internacionalizadas independientemente del lenguaje por defecto de tu navegador.
internationalization.item6 = Crea tu propio locale locale managed bean:
internationalization.item7 = Crea una p\u00c3\u00a1gina JSF para mostrar algunas cadenas internacionalizadas y adjunta por ejemplo tres links (Ingl\u00c3\u00a9s, Catal\u00c3\u00a1n y Castellano) para cambiar el lenguaje de tu aplicaci\u00c3\u00b3n de la siguiente manera.
internationalization.item8 = Como podr\u00c3\u00a1s ver, la vista actual cambia ahora dependiendo del lenguaje seleccionado. Para internacionalizar toda la aplicaci\u00c3\u00b3n, tienes que a\u00c3\u00b1aadir el c\u00c3\u00b3digo siguiente en cualquier p\u00c3\u00a1gina en la que lo necesites o en una plantilla:
internationalization.definition8 = Ahora el lenguaje de las p\u00c3\u00a1ginas depende del lenguaje seleccionado.

# ==============================================================================
# Validations (errGeneratorChck.xhtml, simpleValidation.xhtml, crossFieldValidation.xhtml)
# ==============================================================================

validations.username = Nombre de usuario
validations.lastName = Apellido
validations.email = Correo electr\u00c3\u00b3nico
validations.password = Contrase\u00c3\u00b1a
validations.inidnidate = Fecha expedici\u00c3\u00b3n del DNI
validations.enddnidate = Fecha caducidad del DNI
validations.connDB = Conectar con la BD
validations.submit = Enviar
validations.viewManagedBean = Ver UserBean.java
validations.viewUserVO = UserVO.java
validations.viewJSF = Ver c\u00c3\u00b3digo

# ==============================================================================
# Welcome page (welcome.xhtml)
# ==============================================================================
main.text = El objetivo de este caso de uso es ayudarte a iniciar una aplicaci\u00c3\u00b3n basada \
en Appverse Web y front end JSF2. Ser\u00c3\u00a1s capaz de construir tu aplicaci\u00c3\u00b3n usando los \
componentes b\u00c3\u00a1sicos / siguiendo las recomendaciones que este showcase (basado en la librer\u00c3\u00ada de componentes JavaServer \
Faces, Rich Faces) te ofrece. Este caso de uso muestra:
main.text.layout = Layout recomendado para el projecto
main.text.springJsf = Configuraci\u00c3\u00b3n inicial de las tecnolog\u00c3\u00adas Spring y JSF2
main.text.exceptions = Gesti\u00c3\u00b3n de excepciones
main.text.styles = Estilos (Skins, Css)
main.text.validations = Validaciones JSR 303 
main.text.remotePaging = Paginaci\u00c3\u00b3n remota
main.text.uploadFiles = Subida de ficheros
main.text.internationalization = Internacionalizaci\u00c3\u00b3n

main.links = V\u00c3\u00adnculos r\u00c3\u00a1pidos
main.templating = Plantillas
main.gap = Acerca de este caso de uso
main.i18n = I18N
main.facelets = Facelets
main.remotePagingGrid = Tabla con paginaci\u00c3\u00b3n remota
# ==============================================================================
# Left Menu (menu.xhtml)
# ==============================================================================

menu.group.exceptionHandling = Gesti\u00c3\u00b3n de Excepciones
menu.group.exceptionHandling.uncheckedExceptions = Excepciones Unchecked
menu.group.exceptionHandling.checkedExceptions = Excepciones Checked
menu.group.exceptionHandling.errorPage = P\u00c3\u00a1ginas de error
menu.group.exceptionHandling.errorPage.httpErrorCodes = Gesti\u00c3\u00b3n autom\u00c3\u00a1tica de errores HTTP
menu.group.exceptionHandling.errorPage.avoidMapping = Evitar mapeo de p\u00c3\u00a1ginas JSF como p\u00c3\u00a1ginas de error generales
menu.group.exceptionHandling.lifecycle = Implentaci\u00c3\u00b3n de un gestor de excepciones de aplicaci\u00c3\u00b3n
menu.group.styling = Estilos
menu.group.styling.description = Descripci\u00c3\u00b3n
menu.group.styling.configuration = Configuraci\u00c3\u00b3n
menu.group.styling.css = Skins + Css
menu.group.faceletsTemplates =  Plantillas (facelets)
menu.group.validations = Validaciones
menu.group.validations.simpleValidations = Validaciones simples
menu.group.validations.complexValidations = Validaciones de m\u00c3\u00baltiples campos
menu.group.internationalization = Internacionalizaci\u00c3\u00b3n
menu.group.components = Componentes
menu.group.components.fileUpload = Subida de archivos

# ==============================================================================
# General messages
# ==============================================================================
general.description = Descripci\u00c3\u00b3n
general.close = Cerrar
general.code = C\u00c3\u00b3digo:
general.configuration = Configuraci\u00c3\u00b3n
general.renderedOutput = Salida renderizada
general.with = con
general.print = Imprimir
general.share = Compartir
general.search = Buscar
general.cancel = Cancelar
general.store = Guardar
general.logout = Logout

# ==============================================================================
# Footer
# ==============================================================================

footer.basedOn = Layout basado en

# ==============================================================================
# Unchecked Errors (errGeneratorUnch.xhtml)
# ==============================================================================
uncheckedErrors.firstFeature = Representa fallos en un programa (bugs) - por ejemplo par\u00c3\u00a1metros inv\u00c3\u00a1lidos pasados a un m\u00c3\u00a9todo no privado. Cogido de Java Programming Language, por Gosling, Arnold y Homes: "Excepciones no controladas en ejecuci\u00c3\u00b3n representan condiciones que, generalmente hablando, reflejan errores en la l\u00c3\u00b3gica de tu programa y no son recuperables de una manera razonable en tiempo de ejecuci\u00c3\u00b3n".
uncheckedErrors.secondFeature = Son subclases de RuntimeException y normalmente implementadas usando IllegalArgumentException, NullPointerException, o IllegalStateException
uncheckedErrors.thirdFeature = Un m\u00c3\u00a9todo no est\u00c3\u00a1 obligado a establecer una pol\u00c3\u00adtica para excepciones unchecked que su implementaci\u00c3\u00b3n lanza 
uncheckedErrors.invalidAction = Acci\u00c3\u00b3n inv\u00c3\u00a1lida
uncheckedErrors.errorTest = Test de error
uncheckedErrors.runtimeError = Test de error de ejecuci\u00c3\u00b3n

# ==============================================================================
# Checked Errors (errGeneratorChck.xhtml)
# ==============================================================================
checkedErrors.firstFeature = Representa condiciones inv\u00c3\u00a1lidas en alg\u00c3\u00ban punto fuera del control inmediato del programa (entrada de usuario inv\u00c3\u00a1lida, problemas de base de datos, problemas de red, ficheros inexistentes)
checkedErrors.secondFeature = Son subclases de Exception
checkedErrors.thirdFeature = Un m\u00c3\u00a9todo est\u00c3\u00a1 obligado a establecer una pol\u00c3\u00adtica para todas las excepciones 'checked' lanzadas por su implementaci\u00c3\u00b3n (bien pasar la excepci\u00c3\u00b3n a un nivel superior o gestionarla)
checkedErrors.timeoutError = Test Timeout Error
checkedErrors.sampleFormError = Test error en formulario

# ==============================================================================
# Error Pages (errGeneratorErrCod.xhtml)
# ==============================================================================
errorPages.statusCodes.facet = Como gestionar errores HTTP en las p\u00c3\u00a1ginas
errorPages.statusCodes.showHTTPStatusCodes = Mostrar c\u00c3\u00b3digos de estado HTTP
errorPages.statusCodes.definitionHeader = La mejor manera de establecer p\u00c3\u00a1ginas por defecto para errores HTTP (404, 500, 503...) en tu aplicaci\u00c3\u00b3n web es definirlos en tu web.xml de la siguiente manera :
errorPages.statusCodes.definition = Tu aplicaci\u00c3\u00b3n web muestra el contenido de la p\u00c3\u00a1gina custom error404.xhtml (en vez de la p\u00c3\u00a1gina de error 404 por defecto) cuando la aplicaci\u00c3\u00b3n redirige a un recurso inexistente o se escribe un destino inexistente en la barra de URL. Esto solo aplica para recursos que no terminan en extensi\u00c3\u00b3n *.jsf. Para gestionar los *.jsf desconocidos, es necesario aplicar gesti\u00c3\u00b3n de excepciones JSF2 centralizada  en tu aplicaci\u00c3\u00b3n web para gestionar la excepci\u00c3\u00b3n FacesFileNotFoundException. Puedes ver c\u00c3\u00b3mo hacerlo en la secci\u00c3\u00b3n correspondiente a CustomExceptionHandler.
errorPages.statusCodes.resumeHTTPStatusCodes = Resumen de c\u00c3\u00b3digos de estado HTTP
errorPages.statusCodes.HTTPStatusCode = C\u00c3\u00b3digo de estado HTTP
errorPages.statusCodes.statusCode.continue = Continue
errorPages.statusCodes.statusCode.switchingProtocols = Switching Protocols
errorPages.statusCodes.statusCode.ok = OK
errorPages.statusCodes.statusCode.created = Created
errorPages.statusCodes.statusCode.accepted = Accepted
errorPages.statusCodes.statusCode.nonAuthoritativeInformation = Non-Authoritative Information
errorPages.statusCodes.statusCode.noContent = No Content
errorPages.statusCodes.statusCode.resetContent = Reset Content
errorPages.statusCodes.statusCode.partialContent = Partial Content
errorPages.statusCodes.statusCode.multipleChoices = Multiple Choices
errorPages.statusCodes.statusCode.movedPermanently = Moved Permanently
errorPages.statusCodes.statusCode.movedTemporarily = Moves Temporarily
errorPages.statusCodes.statusCode.seeOther = See Other
errorPages.statusCodes.statusCode.notModified = Not modified 
errorPages.statusCodes.statusCode.useProxy = Use Proxy
errorPages.statusCodes.statusCode.badRequest = Bad Request
errorPages.statusCodes.statusCode.unauthorized = Unauthorized
errorPages.statusCodes.statusCode.paymentRequired = Payment required
errorPages.statusCodes.statusCode.forbidden = Forbidden
errorPages.statusCodes.statusCode.notFound = Not Found
errorPages.statusCodes.statusCode.methodNotAllowed = Method Not Allowed
errorPages.statusCodes.statusCode.notAcceptable = Not Acceptable
errorPages.statusCodes.statusCode.proxyAuth = ProxyAuthentication Required
errorPages.statusCodes.statusCode.requestTimeout = Request Time-Out
errorPages.statusCodes.statusCode.conflict = Conflict
errorPages.statusCodes.statusCode.gone = Gone
errorPages.statusCodes.statusCode.lengthRequired = Length Required
errorPages.statusCodes.statusCode.preconditionFailed = Precondition Failed
errorPages.statusCodes.statusCode.requestEntityLarge = Request Entity Too Large
errorPages.statusCodes.statusCode.requestUrlLarge = Request-URL Too Large
errorPages.statusCodes.statusCode.unsupportedMediaType = Unsupported Media Type
errorPages.statusCodes.statusCode.serverError = Server Error
errorPages.statusCodes.statusCode.notImplemented = Not Implemented
errorPages.statusCodes.statusCode.badGateway = Bad Gateway
errorPages.statusCodes.statusCode.outOfResources = Out of resources
errorPages.statusCodes.statusCode.gatewayTimeout = Gateway Time-Out
errorPages.statusCodes.statusCode.httpVersionNotSupported = HTTP Version not supported
errorPages.statusCodes.pageNotFound = Page Not Found (404)
errorPages.statusCodes.badLink404 = Bad Link (404)
errorPages.statusCodes.serviceUnavailable = Service Unavailable (503)
errorPages.statusCodes.badLink403 = Forbidden Link.html (403)

# ==============================================================================
# Application Error (applicationError.xhtml)
# ==============================================================================
applicationError.heading = Error de aplicaci\u00c3\u00b3n
applicationError.contactItTeam = Por favor, contacte con IT y proporcione la siguiente informaci\u00c3\u00b3n t\u00c3\u00a9cnica
applicationError.cause = Causa de error
applicationError.stackTrace = Error stackTrace

# ==============================================================================
# Custom Exception Handler (errGeneratorCode.xhtml)
# ==============================================================================

customExceptionHandler.definition1 = Implementando un Custom Exception Handler, la aplicaci\u00c3\u00b3n podr\u00c3\u00a1 gestionar diferentes excepciones de manera centralizada y mostrar las excepciones en una o varias p\u00c3\u00a1gians de error. Para poder crear una gesti\u00c3\u00b3n de excepciones propia es necesario:
customExceptionHandler.definition2 = Crear un gestor de excepciones propio que gestiona las excepciones de aplicaci\u00c3\u00b3n. Esta clase handler debe exteneder la clase handling wrapper class (como ExceptionHandlerWrapper class).
customExceptionHandler.definition3 = Crear una clase factory para gesti\u00c3\u00b3n de excepciones propia que es responsable de crear las instancias de la clase gestor de excepciones. La clase factory ha de extender de JSF ExceptionHandlerFactory class.
customExceptionHandler.definition4 = Finalmente, es necesario registrar la factor\u00c3\u00ada del gestor propio de excepciones en el fichero your faces-config.xml.
customExceptionHandler.definition5 = El m\u00c3\u00a9todo m\u00c3\u00a1s importante de la clase CustomExceptionHandler class es el m\u00c3\u00a9todo handle() que es responsable de gestionar las excepciones JSF de la application. El m\u00c3\u00a9todo getUnhandledExceptionQueuedEvents() obtiene todas las excepciones que no se han gestionado todav\u00c3\u00ada. Cada objeto en el objeto Iterable retornado por dicho m\u00c3\u00a9todo representa un objeto ExceptionQueuedEvent. Desde el objeto ExceptionQueuedEvent puedes obtener el objeto ExceptionQueuedEventContext desde el cual puedes obtener el objeto Throwable. Utilizando el objeto Throwable puedes verificar las excepciones que quieres gestionar en tu aplicaci\u00c3\u00b3n.
customExceptionHandler.definition6 = Hay varias maneras de redirigir la respuesta a una p\u00c3\u00a1gina de error de aplicaci\u00c3\u00b3n como dispatch, redirect o utilizando NavigationHandler.
customExceptionHandler.definition7 = A continuaci\u00c3\u00b3n, necesitamos crear CustomExceptionHandlerFactory, la clase factory que es responsable de crear las instancias de la clase CustomExceptionHandler.
customExceptionHandler.definition8 = Finalmente, necesitamos registrar la factor\u00c3\u00ada en el fichero faces-config.xml tal como se muestra a continuaci\u00c3\u00b3n:

# ==============================================================================
# Styling Description (skinDescription.xhtml)
# ==============================================================================

skinDescription.firstFacet = \u00c2\u00bfQu\u00c3\u00a9 son 'skins'?
skinDescription.definition1 = Los skins de aplicaci\u00c3\u00b3n permiten con RichFaces cambiar la apariencia de la aplicaci\u00c3\u00b3n modificando la configuraci\u00c3\u00b3n de colores y decoraci\u00c3\u00b3n de controles y componentes. T\u00c3\u00adpicamente la apareciencia de aplicaciones web se gestiona mediante ficheros CSS (Cascading Style Sheet) asociados a la aplicaci\u00c3\u00b3n pero el 'skinning' permite que tener la configuraci\u00c3\u00b3n separada y ser f\u00c3\u00a1cilmente editable. Los 'skins' consisten en peque\u00c3\u00b1a, generalizada configuraci\u00c3\u00b3n parametrizada de fuentes y colores que pueden aplicarse a m\u00c3\u00baltiples estilos. Esto evita c\u00c3\u00b3digo repetitivo y duplicaci\u00c3\u00b3n de CSS en los ficheros. Los ficheros CSS no quedan completamente reemplazados: los 'skins' funcionan como un nivel de superior, como una extensi\u00c3\u00b3n al CSS est\u00c3\u00a1ndar. Cada 'skin' tiene un conjunto de parametros que se utilizan para definir el tema de la paleta y otros elementos de la interfaz de usuario. Estos par\u00c3\u00a1metros se combinan con declaraciones CSS normales y pueden referenciarse desde CSS utilizando JavaServer Faces Expression Language (EL). Esta funcionalidad 'skinning' de RichFaces tambi\u00c3\u00a9n permite cambiar 'skins' en tiempo de ejecuci\u00c3\u00b3n para que los usuarios puedan personalizar una aplicaci\u00c3\u00b3n al momento.
skinDescription.secondFacet = Uso de 'Skins'
skinDescription.definition2 = RichFaces incluye un conjunto de 'skins' predefinidos. Dichos 'skins' pueden usarse web applications especificando el nombre de 'skin' en el par\u00c3\u00a1metro de contexto org.richfaces.skin en el fichero web.xml. Los 'skins' predefinidos son los siguientes:
skinDescription.definition3 = Para a\u00c3\u00b1adir uno de estos 'skins' a tu aplicaci\u00c3\u00b3n, a\u00c3\u00b1ade el par\u00c3\u00a1metro de contexto org.richfaces.SKIN al descriptor de deploy web.xml:
skinDescription.definition4 = En caso de que necesites resetear todos los estilos y ser completamente responsable del aspecto de tu aplicaci\u00c3\u00b3n, puedes seleccionar un 'skin plano'. Este skin no tiene par\u00c3\u00a1metros de 'skin' y est\u00c3\u00a1 pensado para embeber componentes RichFaces dentro de proyectos existentes con sus propios estilos.
skinDescription.thirdFacet = Resumen sobre 'Skinning'
skinDescription.definition5 = RichFaces 'skins' est\u00c3\u00a1n implmentandos siguiendo el siguiente esquema de tres niveles: 
skinDescription.item1 = Hojas de estilo de componentes
skinDescription.definition6 = Se proporcionan hojas de estilo para cada componente. Los par\u00c3\u00a1metros de estilo CSS se mapean a par\u00c3\u00a1metros de 'skin' definidos en el fichero de propiedades del 'skin'. Este mapeo se consigue mediante el uso de ficheros ECSS.
skinDescription.item2 = Ficheros de propiedades de 'Skin'
skinDescription.definition7 = Los ficheros de propiedades de 'skin' mapean par\u00c3\u00a1metros de 'skin' a constantes de estilo. Las propiedades de 'skin' est\u00c3\u00a1n definidas en ficheros skin.properties.
skinDescription.item3 = Clases de estilo propias
skinDescription.definition8 = Componentes individuales pueden utilizar el atributo styleClass para redefinir elementos espec\u00c3\u00adficos. Estos componentes utilizan los estilos definidos en un fichero CSS en vez de tener el aspecto est\u00c3\u00a1ndar para componentes como se define en las hojas ECSS stylesheets.
skinDescription.titleTable = Tabla de par\u00c3\u00a1metros de 'skin'
skinDescription.definition9 = \u201cConfiguraci\u00c3\u00b3n de par\u00c3\u00a1metros para el skin 'blueSky'\u201d muestra los valores por defecto para la configuraci\u00c3\u00b3n de par\u00c3\u00a1metros del skin 'blueSky'. Estos valores aparecen listados en el fichero blueSky.skin.properties.
skinDescription.parameterName = Nombre de par\u00c3\u00a1metro
skinDescription.defaultValue = Valor por defecto

# ==============================================================================
# Styling Configuration (skinConfiguration.xhtml)
# ==============================================================================

skinConfiguration.yourSkinSelector = Tu selector de 'skin'
skinConfiguration.changingSkin = Cambio de 'skins' RichFaces en tiempo de ejecuci\u00c3\u00b3n
skinConfiguration.definition1 = Configurando tu aplicaci\u00c3\u00b3n basada en RichFaces para utilizar un 'skin' concreto es muy simple, todo lo que tienes que hacer es configurar tu 'skin' en tu web.xml:
skinConfiguration.definition2 = A veces es deseable cambiar el 'skin' en tiempo de ejecuci\u00c3\u00b3n. Quiz\u00c3\u00a1s incluso quieras salvar un 'skin' concreto en tus preferencias.
skinConfiguration.item1 = En vez de tener un nombre de 'skin' fijo, es necesario utilizar una expresi\u00c3\u00b3n EL como a continuaci\u00c3\u00b3n:
skinConfiguration.item2 = skinBean es el nombre del JSF managed bean que necesitas implementar:
skinConfiguration.item3 = Deber\u00c3\u00adas de inicializar la propiedad 'skin' con el valor de alg\u00c3\u00ban 'skin' por defecto. Puedes hacerlo en tu faces-config.xml:
skinConfiguration.item4 = Finalmente, puedes crear un selector para permitir el cmabio de 'skin' en tiempo de ejecuci\u00c3\u00b3n. Aqu\u00c3\u00ad tienes un ejemplo:
skinConfiguration.definition3 = El primer item de este selector (app) representa un 'skin' propio. Necesitas crear todos los 'skins' propios que quieras utilizar con nombre: nameOfSkin.skin.properties. 

# ==============================================================================
# Styling + Css (skinCss.xhtml)
# ==============================================================================

skinCss.firstFacet = Personalizaci\u00c3\u00b3n de 'skins'
skinCss.definition1 = Los 'skins' en RichFaces pueden personalizarse en cada uno de estos tres niveles:
skinCss.item1 = Ficheros de propiedades de 'Skin'
skinCss.definition2 =  Las interfaces de aplicaci\u00c3\u00b3n pueden modificarse alterando los valores de los par\u00c3\u00a1metros de 'skin' en el propio 'skin'. Edita los valores constantes definidos en el fichero skin.properties para cambiar el estilo de cada componente mapado a dicha propiedad.
skinCss.item2 = Hoja de estilos de componente
skinCss.definition3 = Mapeos y otros atributos de estilos listados en un fichero ECSS de componente pueden editarse. Edita el fichero ECSS para cambiar los estilos de todos los componentes de ese tipo.
skinCss.item3 = Clases de estilos de componente personalizados
skinCss.definition4 = Componentes individuales pueden utilizar el atributo 'styleClass' para utilizar una clase de estilo \u00c3\u00banica. A\u00c3\u00b1ade la nueva clase de estilo al CSS de la aplicaci\u00c3\u00b3n y referencialo desde un componente individual con el atributo 'styleClass'.
skinCss.item4 = Sobreescribiendo hojas de estilo en la aplicaci\u00c3\u00b3n
skinCss.definition5 = Puedes cargar hojas de estilo propios utilizando <h:outputStylesheet> para reescribir o extender estilos definidos por una clase de estilo de componentes.
skinCss.info.title = Personalizaci\u00c3\u00b3n de 'skins' modificando / extendiendo clases de estilo de componente
skinCss.info.explanation = Si quieres extender / sobreescribir definiciones de hojas de estilo con tus propias hojas de estilo, aseg\u00c3\u00barate de poner tus definiciones para que se rendericen en el orden correcto de ocurrencia.

skinCss.firstFacet.facet = Ejemplo de skinning simple
skinCss.definition6 = Utilizando cualquier componente, como un panel, sin especificar una clase de estilo se utilizar\u00c3\u00a1n los par\u00c3\u00a1metros de 'skin' por defecto para ese componente.
skinCss.definition7 = Cuando se renderiza para mostrar en pnatalla, el panel consite en dos elementos HTML: un elemento <div> contenedor y un elemento <div> para el cuerpo (contenido) del panel. El elemento contenedor para un panel sin styleClass especificado se renderiza de la siguente manera:
skinCss.definition8 = Para personalizar la apariencia del panel acorde al esquema de tres niveles, ajusta los estilos de la siguiente manera:
skinCss.item5 = Cambia las definiciones para los par\u00c3\u00a1metros generalBackgroundColor o panelBorderColor en el 'skin'. Esto provocar\u00c3\u00a1 que todos los paneles de la aplicaci\u00c3\u00b3n cambien a la nueva configuraci\u00c3\u00b3n.
skinCss.item6 = Redefine la clase rf-p en el CSS de la aplicaci\u00c3\u00b3n. Esto tambi\u00c3\u00a9n causar\u00c3\u00a1 que todos los paneles de la aplicaci\u00c3\u00b3n cambien a la nueva configuraci\u00c3\u00b3n, aunque el 'skin' en s\u00c3\u00ad mismo no se haya modificado. Ninguna propiedad que no est\u00c3\u00a9 mapeada a un par\u00c3\u00a1metro de 'skin' deber\u00c3\u00ada de redefinirse de esta manera.
skinCss.item7 = Especifica un atributo styleClass diferente para aplicar estilo a un componente individual. Si se utiliza un atributo styleClass, la clase de estilo especificada se aplica al componente que puede extender o sobreescribir los estilos por defecto.
skinCss.definition9 = La clase de estilo propia se a\u00c3\u00b1ade al CSS y se aplica al componente cuando se renderiza para mostrarse en pantalla:

skinCss.secondFacet = Soporte para esquinas redondeadas
skinCss.definition10 = Soporte para contornos redondeados en tu 'skin' mediante el par\u00c3\u00a1metro de 'skin' panelBorderRadius. El valor de este par\u00c3\u00a1metro se corresponde a la propiedad CSS 3 border-radius. Esta propiedad CSS 3 es ignorada por navegadores antiguos y el 'skin' degrada a esquinas cuadradas.
skinCss.definition11 = La unidad del par\u00c3\u00a1metro de 'skin' panelBorderRadius han de ser px (pixels) or % (porcentaje).

skinCss.thirdFacet = Ficheros ECSS
skinCss.definition12 = RichFaces utiliza ficheros ECSS  para a\u00c3\u00b1adir functionalidad extra al proceso de skinning. Los ficheros ECSS son ficheros CSS files que utilizan Expression Language (EL) para conectar estilos con propiedades de 'skin'.
skinCss.secondFacet.facet = Mappings de estilo ECSS
skinCss.definition13 = El c\u00c3\u00b3digo ECSS para el componente <rich:panel> contiene estilos para el panel y su contenido (body):
skinCss.definition14 = define los estilos del panel:
skinCss.item8 = La propiedad CSS 'background-color' se corresponde con el par\u00c3\u00a1metro de skin 'generalBackgroundColor'
skinCss.item9 = La propiedad CSS 'color' se corresponde con el par\u00c3\u00a1metro skin 'panelBorderColor'.
skinCss.definition15 = define los estilos del contenido del panel (body):
skinCss.item10 = La propiedad CSS 'font-family' se corresponde con el par\u00c3\u00a1metro de 'skin' 'generalFamilyFont'.
skinCss.item11 = La propiedad CSS 'font-size' se corresponde con el par\u00c3\u00a1metro de 'skin' 'generalSizeFont'.
skinCss.item12 = La propiedad CSS 'color' se corresponde con el par\u00c3\u00a1metro de 'skin' 'generalTextColor'.

skinCss.fourthFacet = Controles de 'skinning' est\u00c3\u00a1ndar
skinCss.definition16 = Controles de HTML est\u00c3\u00a1ndar que se usan junto con componentes RichFaces Standard HTML incorporan tambi\u00c3\u00a9n un tema para que la interfaz de usuario sea coherente.
skinCss.fourthFacet.firstFacet = Automatic skinning
skinCss.definition17 = Las propiedades de estilo de skinning se aplican autom\u00c3\u00a1ticamente a controles basados en sus nombres y tipo de atributos. Si los elementos HTML est\u00c3\u00a1n referenciados en hojas de estilo de skin est\u00c3\u00a1ndar los controles se mostrar\u00c3\u00a1n de acuerdo al mapeo de propiedades de skin.
skinCss.definition18 = A los controles HTML est\u00c3\u00a1ndar Standard se les aplica 'skin' de esta manera por defecto. Para sobrescribir este comportamiento y evitar que los 'skins' RichFaces se apliquen a controles HTML est\u00c3\u00a1ndar, a\u00c3\u00b1ade el par\u00c3\u00a1metro de contexto 'org.richfaces.enableControlSkinning' en el descriptor de deploy web.xml con valor 'false':
skinCss.fourthFacet.secondFacet = Aplicando 'skins' con la clase 'rfs-ctn'
skinCss.definition19 = Las propiedades de estilo de skinning pueden especificarse en una clase CSS separada. Esto no est\u00c3\u00a1 habilitado por defecto pero puede habilitarse mediante el par\u00c3\u00a1metro de contexto 'org.richfaces.enableControlSkinningClasses' en el descriptor de deploy web.xml:
skinCss.definition20 = Cuando est\u00c3\u00a1 habilitado, una hoja de estilo con clases predefinidas ofrece una clase CSS especial llamada 'rfs-ctn'. Referencia la clase 'rfs-ctn' desde cualquier elemento contenedor (como por ejemplo el elemento <div>) para aplicar estilo a todos los cotroles HTML que est\u00c3\u00a1n dentro del contenedor.
skinCss.definition21 = En el CSS tambi\u00c3\u00a9n pueden especificarse controles HTML estandard espec\u00c3\u00adficamente. Utiliza como referencia el fichero /core/impl/src/main/resources/META-INF/resources/skinning_both.ecss en richfaces-ui.jar para ejemplos de clases CSS definidas especialmente con par\u00c3\u00a1metros de skin para controles HTML.

# ==============================================================================
# Templating facelets (skinCss.xhtml)
# ==============================================================================

templating.definition = El t\u00c3\u00a9rmino Facelets hace referencia al lenguaje de declaraci\u00c3\u00b3n de la vista para tecnolog\u00c3\u00ada JavaServer Faces. JavaServer Pages (JSP) technology, previamente utilizada como tecnolog\u00c3\u00ada de presentaci\u00c3\u00b3n para JavaServer Faces, no soporta todas las nuevas caracter\u00c3\u00adsticas disponibles en JavaServer Faces in the Java EE 6 platform. La tecnolog\u00c3\u00ada JSP se considera una tecnolog\u00c3\u00ada de presentaci\u00c3\u00b3n deprecada para JavaServer Faces. Facelets es una parte de la especificaci\u00c3\u00b3n de JSF y tambi\u00c3\u00a9n la tecnolog\u00c3\u00ada de presentaci\u00c3\u00b3n recomendada para aplicaciones basadas en JSF.
templating.component = El tag ui:component inserta una nueva instancia UIComponent en un \u00c3\u00a1rbol JSF. Cualquier componente o fragmento de contenido que est\u00c3\u00a9 fuera de este tag ser\u00c3\u00a1 ignorado por el gestor de vistas Facelets. Cualquier componente o fragmentos de contenido dentro de este tag se a\u00c3\u00b1adir\u00c3\u00a1n al \u00c3\u00a1rbol de componentes como hijos de la instancia UIComponent. Puedes ver tambi\u00c3\u00a9n ui:fragment.
templating.composition = El tag ui:composition es un tag para plantilla que incluye el contenido que a su vez est\u00c3\u00a1 incluido ne otro Facelet. Cualquier contenido fuera del tag ui:composition ser\u00c3\u00a1 ignorado por el gestor de vistas Facelets. Cualquier contenido dentro del tag ui:composition ser\u00c3\u00a1 incluido cuando otro Facelet incluye la p\u00c3\u00a1gina conteniendo este tag ui:composition. Puedes ver tambi\u00c3\u00a9n ui:include.
templating.debug = El tag ui:debug te permite mostrar informaci\u00c3\u00b3n \u00c3\u00batil sobre el \u00c3\u00a1rbol de componentes JSF y las variables en diferentes scopes en tu navegador cuando pruebas tus p\u00c3\u00a1ginas JSF. El atributo 'hotkey' especifica una combinaci\u00c3\u00b3n de teclas (CTRL + SHIFT + 0 por defecto) para mostrar una ventana de popup conteniendo la informaci\u00c3\u00b3n. El tag UI Debug puede habilitarse o deshabilitarse configurando el atributo 'rendered'.
templating.decorate = El tag ui:decorate es un tag para plantilla que decora contenido incluido desde otro Facelet. Cualquier contenido fuera del tag ui:decorate ser\u00c3\u00a1 mostrado por el gestor de vistas Facelets. Cualquier contenido dentro del tag decorate se pasar\u00c3\u00a1 a la plantilla asociada como par\u00c3\u00a1metro o simplemente se ignorar\u00c3\u00a1. Puedes utilizar ui:define tags anidados para pasar contenido con nombre asociado a la plantilla asociada. Puedes ver ui:insert para m\u00c3\u00a1s informaci\u00c3\u00b3n.
templating.define = El tag ui:define es un tag para plantilla que define contenido con nombre asociado para insertarse en una plantilla. El valor del nombre de atributo ha de coincidir con el de un tag ui:insert en la plantilla de destino para el contenido a incluirse por nombre.
templating.fragment = El tag ui:fragment inserta una nueva instancia ui:component dentro del \u00c3\u00a1rbol de componentes JSF. Cuaqluier componente o fragmento de contenido fuera de este tag ser\u00c3\u00a1 incluido por el gestor de vistas Facelets. Cualquier componente o fragmento dentro de este tag se a\u00c3\u00b1adir\u00c3\u00a1 al \u00c3\u00a1rbol de componentes como hijos de esta componente de instancia. Puedes ver tambi\u00c3\u00a9n ui:component.
templating.include = El tag ui:include es un tag server-side para inclusi\u00c3\u00b3n en Facelets. Simplemente incluye el documento al que apunta el atributo "src" como parte de la p\u00c3\u00a1gina JSF actual. El documento includo deber\u00c3\u00ada de utilizar un componente o tag de composici\u00c3\u00b3n para eliminar lenguaje de marcas innecesario o simplemente podr\u00c3\u00ada contener un fragmento de XHTML or XML.
templating.insert = El tag ui:insert es un tag para plantila que declara un elemento de contenido asoci\u00c3\u00a1ndole un nombre para ser definido por otro Facelet. Puede utilizarse con el tag ui:define para pasar valores entre Facelets.
templating.param =  El tag ui:param se utiliza para pasar objetos como variables por nombre entre Facelets. El nombre del atributo del tag UI Param deber\u00c3\u00ada tener correspondencia con el nombre de atributo de un tag ui:define contenido en ui:composition o ui:decorate en la p\u00c3\u00a1gina plantilla que recibe el objeto. El tag UI Param tag puede tambi\u00c3\u00a9n utilizarse para pasar objetos a otra p\u00c3\u00a1gina utilizando el tag ui:include.
templating.repeat = El tag ui:repeat se utiliza para iterar sobre una colecci\u00c3\u00b3n de objetos expuestos a la p\u00c3\u00a1gina JSF como expresi\u00c3\u00b3n EL. Est\u00c3\u00a1 pensado para reemplazar al tag c:forEach de JSTL Core tag library.
templating.remove = El tag ui:remove se utiliza para especificar tags or bloques de contenido que deber\u00c3\u00adan de ser eliminados de tu p\u00c3\u00a1gina por el gestor de vistas Facelets en tiempo de compilaci\u00c3\u00b3n. Este tag no tiene atributos. Ten en cuenta que el proceso de compilaci\u00c3\u00b3n de Facelets es mucho m\u00c3\u00a1s r\u00c3\u00a1pido que el proces o de compilaci\u00c3\u00b3n JSP  porque no se genera Java bytecode sino que es de hecho generado y compilado en segundo plano cuando visitas la p\u00c3\u00a1gina. El tag ui:remove se utiliza para especificar tags o bloques de contenido que deber\u00c3\u00adan de ser eliminado de tu p\u00c3\u00a1gina por el gestor de vistas facelets en tiempo de ejecuci\u00c3\u00b3n. Este tag no tiene atributos.

# ==============================================================================
# File Upload (fileUpload.xhtml)
# ==============================================================================

fileUpload.message = Solo se aceptan archivos JPG, GIF, PNG and BMP
fileUpload.panel.title = Informaci\u00c3\u00b3n de ficheros subidos al servidor
fileUpload.noFiles = No hay ficheros subidos al servidor actualmente
fileUpload.fileName = Nombre de archivo:
fileUpload.fileLength = Logitud del archivo (bytes):
fileUpload.clearUploadedData = Eliminar datos subidos
fileUpload.viewManagedBean = Ver FileUploadBean.java
fileUpload.viewJSF = Ver c\u00c3\u00b3digo
fileUpload.viewSupportFile = Ver UploadedImage.java

# ==============================================================================
# Remote paging Grid (userGrid.xhtml)
# ==============================================================================

pagingGrid.title = Ejemplo de grid con paginaci\u00c3\u00b3n remota
pagingGrid.tableTitle = Grid paginado de usuarios
pagingGrid.resetSorting = Reset ordenaci\u00c3\u00b3n
pagingGrid.tooltip.edit = Editar
pagingGrid.tooltip.delete = Borrar
pagingGrid.editDetail = Editar detalles de usuario