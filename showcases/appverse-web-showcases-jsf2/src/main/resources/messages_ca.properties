#Copyright (c) 2012 GFT Appverse, S.L., Sociedad Unipersonal.
#
# This Source Code Form is subject to the terms of the Mozilla Public 
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/. 
#
# Redistribution and use in source and binary forms, with or without modification, 
# are permitted provided that the conditions of the Mozilla Public License v2.0 
# are met.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. EXCEPT IN CASE OF WILLFUL MISCONDUCT OR GROSS NEGLIGENCE, IN NO EVENT
# SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR OTHERWISE) 
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
# POSSIBILITY OF SUCH DAMAGE.

# ==============================================================================
# Component Errors
# ==============================================================================
javax.faces.component.UIInput.CONVERSION=Conversion error occurred
javax.faces.component.UIInput.REQUIRED= Aquest camp és obligatori
javax.faces.component.UIInput.UPDATE=An error occurred when processing your submitted information.
javax.faces.component.UISelectOne.INVALID=Value is not valid
javax.faces.component.UISelectMany.INVALID=Value is not valid

# ==============================================================================
# Validator Errors
# ==============================================================================

javax.faces.validator.NOT_IN_RANGE=Specified attribute is not between the expected values of {0} and {1}.
javax.faces.validator.DoubleRangeValidator.MAXIMUM=Value is greater than allowable maximum of ''{0}''
javax.faces.validator.DoubleRangeValidator.MINIMUM=Value is less than allowable minimum of ''{0}''
javax.faces.validator.DoubleRangeValidator.NOT_IN_RANGE=Specified attribute is not between the expected values of {0} and {1}.
javax.faces.validator.DoubleRangeValidator.TYPE=Value is not of the correct type
javax.faces.validator.LengthValidator.MAXIMUM=Value is greater than allowable maximum of ''{0}''
javax.faces.validator.LengthValidator.MINIMUM=Value is less than allowable minimum of ''{0}''
javax.faces.validator.LongRangeValidator.MAXIMUM=Value is greater than allowable maximum of ''{0}''
javax.faces.validator.LongRangeValidator.MINIMUM=Value is less than allowable minimum of ''{0}''
javax.faces.validator.LongRangeValidator.NOT_IN_RANGE=Specified attribute is not between the expected values of {0} and {1}.
javax.faces.validator.LongRangeValidator.TYPE=Value is not of the correct type.
javax.faces.converter.DateTimeConverter.DATE=Please enter a valid date. 
javax.faces.converter.DateTimeConverter.DATE_detail=Please enter a valid date. Example: {1}
javax.faces.converter.IntegerConverter.INTEGER=Aquest camp ha de ser numèric
javax.validation.constraints.Future.message=Aquesta data ha de ser futura

# ==============================================================================
# Calendar
# ==============================================================================
RICH_CALENDAR_APPLY_LABEL=Aplicar
RICH_CALENDAR_TODAY_LABEL=Avui
RICH_CALENDAR_CLOSE_LABEL=Tancar
RICH_CALENDAR_OK_LABEL=Acceptar
RICH_CALENDAR_CLEAN_LABEL=Netejar
RICH_CALENDAR_CANCEL_LABEL=Cancel.lar

# ==============================================================================
# Internationalization (internationalization.xhtml)
# ==============================================================================

internationalization.language.title = Internacionalització en JSF2
internationalization.language.ENGLISH = Anglès
internationalization.language.CATALAN = Català
internationalization.language.SPANISH = Castellà
internationalization.firstFacet = Internationalize your JSF2 application
internationalization.definition1 = JSF2 (JSF) as many Java based products is designed for easy internationalization experience. One of the main feature used in localizing components is the Message Bundles. Message Bundles are simply text files (properties files), and composed of key/value pairs. These are easy to use. The main is to have one properties file per language that you want to use, for instance one for English, another for Catalan, Spanish or whatever else language, you load a MessageBundle with the current locale and get values from files. You can at any time add other files and merely other languages. In order to internationalize your JSF2 application you will need to follow next steps. 
internationalization.secondFacet = Declare your bundle (properties files)
internationalization.definition2 = You can declare the Message Bundles in two ways.
internationalization.item1 = The simplest way is to supply the declaration in your faces-config.xml as follows:
internationalization.item2 = Instead of using a global resource bundle declaration, you can add the f:load-Bundle element to each JSF page that needs access to the bundle, like this:
internationalization.definition3 = In either cases, the messages in the bundle are accessible through a map variable with the name "msg". The resource bundle name must be ended by .properties (messages.properties).
 
internationalization.thirdFacet = Declare your default and supported locales
internationalization.definition4 = In your faces-config.xml:

internationalization.fourthFacet = How to use resource bundle
internationalization.definition5 = In any .jsf file use the variable defined in faces-config.xml or with <f:loadBundle>. The variable is called here "msg". This variable is to be used  with a key defined in a properties file. For instance to get the localized string for "name" use:
internationalization.definition6 = If you want to use localized strings in your managed beans:
internationalization.item3 = Get the locale used by the browser :
internationalization.item4 = Load the Resource Bundle associated with this locale, using the full path and base name (also relative is valid):
internationalization.item5 = You can get any value using its key in the properties file :

internationalization.fifthFacet = Create your Locale Bean
internationalization.definition7 = You can use localized and internationalized strings independently from the default language of your browser.
internationalization.item6 = Create your own locale managed bean:
internationalization.item7 = Create a JSF page to display some internationalized strings and attach e.g 3 links (English, Catalan and Spanish) to change language of your application as follows.
internationalization.item8 = As you can test, the current view changes now dependending on the language selected. In order to internationalize all the application you need to add the code below in any page you want or your template:
internationalization.definition8 = Now, the language of any/all page/s depends on the language selected.

# ==============================================================================
# Validations (errGeneratorChck.xhtml, simpleValidation.xhtml, crossFieldValidation.xhtml)
# ==============================================================================

validations.username = Nom d'usuari
validations.lastName = Cognom
validations.email = Correu electrònic
validations.password = Contrasenya
validations.inidnidate = Data d'emissió del DNI
validations.enddnidate = Data de caducitat del DNI
validations.connDB = Conectar a la BD
validations.submit = Enviar
validations.viewManagedBean = View UserBean.java
validations.viewUserVO = UserVO.java
validations.viewJSF = View source

# ==============================================================================
# Welcome page (welcome.xhtml)
# ==============================================================================
main.text = L'objectiu d'aquest cas d'ús és ajudar-te a iniciar una aplicació basada en \
Appverse Web i front end JSF2. Seràs capaç de construir la teva aplicació emprant els \
components bàsics que aquest showcase (basat en una llibreria de components per JavaServer \
Faces anomenada Rich Faces) t'ofereix. Aquest cas d'ús mostra:
main.text.layout = Layout recomanat pel projecte
main.text.springJsf = Configuració inicial de les tecnologies Spring i JSF2
main.text.exceptions = Gestió d'excepcions
main.text.styles = Estils (Skins, Css)
main.text.validations = Validacions JSR 303
main.text.remotePaging = Paginació remota
main.text.uploadFiles = Pujada de fitxers
main.text.internationalization = Internacionalització


main.links = Accessos ràpids
main.templating = Plantilles
main.gap = Sobre aquest cas d'ús
main.i18n = I18N
main.facelets = Facelets
main.remotePagingGrid = Taula amb paginació remota
# ==============================================================================
# Left Menu (menu.xhtml)
# ==============================================================================

menu.group.exceptionHandling = Gestió d'Excepcions
menu.group.exceptionHandling.uncheckedExceptions = Excepcions Unchecked
menu.group.exceptionHandling.checkedExceptions = Excepcions Checked
menu.group.exceptionHandling.errorPage = Pàgines d'error
menu.group.exceptionHandling.errorPage.httpErrorCodes = Gestió automàtica de errors HTTP
menu.group.exceptionHandling.errorPage.avoidMapping = Evitar mapeig de pàgines JSF com a pàgines d'error generals
menu.group.exceptionHandling.lifecycle = Implementació d'un gestor d'excepcions d'aplicació
menu.group.styling = Estils
menu.group.styling.description = Descripció
menu.group.styling.configuration = Configuració
menu.group.styling.css = Skins + Css
menu.group.faceletsTemplates =  Plantilles (Facelets)
menu.group.validations = Validacions
menu.group.validations.simpleValidations = Validacions simples
menu.group.validations.complexValidations = Validacions de múltiples camps
menu.group.internationalization = Internacionalització
menu.group.components = Components
menu.group.components.fileUpload = Pujada d'arxius

# ==============================================================================
# General messages
# ==============================================================================
general.description = Descripció
general.close = Tancar
general.code = Codi:
general.configuration = Configuració
general.renderedOutput = Sortida
general.with = amb
general.print = Imprimir
general.share = Compartir
general.search = Cercar
general.cancel = Cancel·lar
general.store = Guardar
general.logout = Logout

# ==============================================================================
# Footer (footer.xhtml)
# ==============================================================================

footer.basedOn = Layout basat en

# ==============================================================================
# Unchecked Errors (errGeneratorUnch.xhtml)
# ==============================================================================
uncheckedErrors.firstFeature = Represent defects in the program (bugs) - often invalid arguments passed to a non-private method. To quote from The Java Programming Language, by Gosling, Arnold, and Holmes : "Unchecked runtime exceptions represent conditions that, generally speaking, reflect errors in your program's logic and cannot be reasonably recovered from at run time."
uncheckedErrors.secondFeature = Are subclasses of RuntimeException, and are usually implemented using IllegalArgumentException, NullPointerException, or IllegalStateException
uncheckedErrors.thirdFeature = A method is not obliged to establish a policy for the unchecked exceptions thrown by its implementation (and they almost always do not do so)
uncheckedErrors.invalidAction = Invalid Action
uncheckedErrors.errorTest = Error Test
uncheckedErrors.runtimeError = Runtime Error

# ==============================================================================
# Checked Errors (errGeneratorChck.xhtml)
# ==============================================================================
checkedErrors.firstFeature = Represent invalid conditions in areas outside the immediate control of the program (invalid user input, database problems, network outages, absent files)
checkedErrors.secondFeature = Are subclasses of Exception
checkedErrors.thirdFeature = A method is obliged to establish a policy for all checked exceptions thrown by its implementation (either pass the checked exception further up the stack, or handle it somehow)
checkedErrors.timeoutError = Timeout Error
checkedErrors.sampleFormError = Form error

# ==============================================================================
# Error Pages (errGeneratorErrCod.xhtml)
# ==============================================================================
errorPages.statusCodes.facet = How to handle HTTP error pages
errorPages.statusCodes.showHTTPStatusCodes = Show HTTP Status Codes
errorPages.statusCodes.definitionHeader = The best way to set up some default pages for HTTP errors (404, 500, 503...) in your webapp is to define them in your web.xml as follows :
errorPages.statusCodes.definition = Your web application is now showing the content of custom error404.xhtml (instead of web browser's 404 default page) when the webapp redirects (or you type some illegal destination in the URL bar) to an unknown resource. It JUST happens when the demanded resource doesn't end with jsf format. In order to manage the unknown *.jsf, you need to apply the centralized JSF2 exception-handling mechanism on your webapp and handle FacesFileNotFoundException. View CustomExceptionHandler section.
errorPages.statusCodes.resumeHTTPStatusCodes = HTTP Status Codes Resume
errorPages.statusCodes.HTTPStatusCode = HTTP Status Code
errorPages.statusCodes.statusCode.continue = Continue
errorPages.statusCodes.statusCode.switchingProtocols = Switching Protocols
errorPages.statusCodes.statusCode.ok = OK
errorPages.statusCodes.statusCode.created = Created
errorPages.statusCodes.statusCode.accepted = Accepted
errorPages.statusCodes.statusCode.nonAuthoritativeInformation = Non-Authoritative Information
errorPages.statusCodes.statusCode.noContent = No Content
errorPages.statusCodes.statusCode.resetContent = Reset Content
errorPages.statusCodes.statusCode.partialContent = Partial Content
errorPages.statusCodes.statusCode.multipleChoices = Multiple Choices
errorPages.statusCodes.statusCode.movedPermanently = Moved Permanently
errorPages.statusCodes.statusCode.movedTemporarily = Moves Temporarily
errorPages.statusCodes.statusCode.seeOther = See Other
errorPages.statusCodes.statusCode.notModified = Not modified 
errorPages.statusCodes.statusCode.useProxy = Use Proxy
errorPages.statusCodes.statusCode.badRequest = Bad Request
errorPages.statusCodes.statusCode.unauthorized = Unauthorized
errorPages.statusCodes.statusCode.paymentRequired = Payment required
errorPages.statusCodes.statusCode.forbidden = Forbidden
errorPages.statusCodes.statusCode.notFound = Not Found
errorPages.statusCodes.statusCode.methodNotAllowed = Method Not Allowed
errorPages.statusCodes.statusCode.notAcceptable = Not Acceptable
errorPages.statusCodes.statusCode.proxyAuth = ProxyAuthentication Required
errorPages.statusCodes.statusCode.requestTimeout = Request Time-Out
errorPages.statusCodes.statusCode.conflict = Conflict
errorPages.statusCodes.statusCode.gone = Gone
errorPages.statusCodes.statusCode.lengthRequired = Length Required
errorPages.statusCodes.statusCode.preconditionFailed = Precondition Failed
errorPages.statusCodes.statusCode.requestEntityLarge = Request Entity Too Large
errorPages.statusCodes.statusCode.requestUrlLarge = Request-URL Too Large
errorPages.statusCodes.statusCode.unsupportedMediaType = Unsupported Media Type
errorPages.statusCodes.statusCode.serverError = Server Error
errorPages.statusCodes.statusCode.notImplemented = Not Implemented
errorPages.statusCodes.statusCode.badGateway = Bad Gateway
errorPages.statusCodes.statusCode.outOfResources = Out of resources
errorPages.statusCodes.statusCode.gatewayTimeout = Gateway Time-Out
errorPages.statusCodes.statusCode.httpVersionNotSupported = HTTP Version not supported
errorPages.statusCodes.pageNotFound = Page Not Found (404)
errorPages.statusCodes.badLink404 = Bad Link (404)
errorPages.statusCodes.serviceUnavailable = Service Unavailable (503)
errorPages.statusCodes.badLink403 = Forbidden Link.html (403)

# ==============================================================================
# Application Error (applicationError.xhtml)
# ==============================================================================
applicationError.heading = Application Error
applicationError.contactItTeam = Please contact IT team and provide them the following technical information
applicationError.cause = Error cause
applicationError.stackTrace = Error stackTrace

# ==============================================================================
# Custom Exception Handler (errGeneratorCode.xhtml)
# ==============================================================================

customExceptionHandler.definition1 = By implementing the Custom Exception Handler, the application will be able to handle different exceptions in a centralized place and display the exception information in an/some error page/s. In order to create a custom exception handler in JSF2 applications we need to do:
customExceptionHandler.definition2 = Create a custom exception handler class that handles the application exceptions. This handler class should extend an exception handling wrapper class (such as the ExceptionHandlerWrapper class).
customExceptionHandler.definition3 = Create a custom exception handler factory class that is responsible for creating the instances of the exception handler class. The custom exception handler class should extend the JSF ExceptionHandlerFactory class.
customExceptionHandler.definition4 = Finally, register the custom exception handler factory class in your faces-config.xml file.
customExceptionHandler.definition5 = The most important method of the CustomExceptionHandler class is the handle() method, which is responsible for handling JSF application exceptions. The getUnhandledExceptionQueuedEvents() method gets all the unhandled exceptions in the JSF application. Every item in the returned Iterable object of this method represents an ExceptionQueuedEvent object. From the ExceptionQueuedEvent object you can get the ExceptionQueuedEventContext object, from which you can retrieve the Throwable object. Using the Throwable object, you can verify the exceptions you want to handle in the applications.
customExceptionHandler.definition6 = There are several ways to redirect the response to an application error page such as dispatch, redirect or using the most common way: the NavigationHandler.
customExceptionHandler.definition7 = Next, we need to create CustomExceptionHandlerFactory, the custom exception handler factory class that is responsible for creating the instances of the CustomExceptionHandler class.
customExceptionHandler.definition8 = Finally, we need to register the custom exception handler factory class in the faces-config.xml file of the application, as shown below:

# ==============================================================================
# Styling Description (skinDescription.xhtml)
# ==============================================================================

skinDescription.firstFacet = What are skins?
skinDescription.definition1 = Application skins are used with the RichFaces framework to change the appearance of an application through setting the colors and decoration of controls and components. Typically the appearance of web applications is handled through the CSS (Cascading Style Sheet) files associated with the application, but skinning allows the settings in a CSS file to be abstracted and easily edited. Skins consist of a small, generalized set of font and color parameters that can be applied to multiple different styles. This avoids repetitive coding and duplication in CSS files. CSS files are not completely replaced: skins work as a high-level extension to standard CSS. Each skin has a set of skin-parameters, which are used to define the theme palette and other elements of the user interface. These parameters work together with regular CSS declarations, and can be referred to from within CSS using JavaServer Faces Expression Language (EL). The skinning feature of RichFaces also allows skins to be changed at runtime, so users can personalize an application's appearance on the fly.
skinDescription.secondFacet = Using skins
skinDescription.definition2 = RichFaces includes a number of predefined skins. These skins can be used in RichFaces web applications by specifying the skin name in the org.richfaces.skin context parameter in the web.xml settings file. The predefined skins are as follows:
skinDescription.definition3 = To add one of these skins to your application, add the org.richfaces.SKIN context parameter to the web.xml configuration file:
skinDescription.definition4 = In case you need to reset all styles and be fully responsible for the look and feel of your application you can set the skin to plain. The skin plain contains no skin parameters and is intended for embedding RichFaces components into existing projects with their own styles.
skinDescription.thirdFacet = Skinning overview
skinDescription.definition5 = RichFaces skins are implemented using the following three-level scheme: 
skinDescription.item1 = Component stylesheets
skinDescription.definition6 = Stylesheets are provided for each component. CSS style parameters map to skin parameters defined in the skin property file. This mapping is accomplished through the use of ECSS files.
skinDescription.item2 = Skin property files
skinDescription.definition7 = Skin property files map skin parameters to constant styles. Skin properties are defined in skin.properties files.
skinDescription.item3 = Custom style classes
skinDescription.definition8 = Individual components can use the styleClass attribute to redefine specific elements. These components then use the styles defined in a CSS file instead of the standard look for components as defined by the ECSS stylesheets.
skinDescription.titleTable = Skin parameters table
skinDescription.definition9 = Parameter settings for the blueSky skin lists the default values for the parameter settings in the blueSky skin. These values are all listed in the blueSky.skin.properties file.
skinDescription.parameterName = Parameter name
skinDescription.defaultValue = Default value

# ==============================================================================
# Styling Configuration (skinConfiguration.xhtml)
# ==============================================================================

skinConfiguration.yourSkinSelector = Your Skin Selector
skinConfiguration.changingSkin = Changing RichFaces skins in runtime
skinConfiguration.definition1 = Setting your RichFaces application to use a particular skin is very simple, all you have to do is set skin to use in your web.xml:
skinConfiguration.definition2 = It is sometimes desirable to change the skins in runtime. You might even want to save a particular skin in your preferences.
skinConfiguration.item1 = Instead of hard coding a skin name, you need to set an EL expression as follows:
skinConfiguration.item2 = skinBean is a name of JSF managed bean that you need to implement:
skinConfiguration.item3 = You should initialize the skin property to some initial skin value. Write in your faces-config.xml:
skinConfiguration.item4 = Finally, you can create a selector to allow to change skin in runtime. This is an example:
skinConfiguration.definition3 = The first item of this selector (app) represents a custom skin. You need to create all custom skin files you want with name nameOfSkin.skin.properties. The other items represent the skins Richfaces library comes with.

# ==============================================================================
# Styling + Css (skinCss.xhtml)
# ==============================================================================

skinCss.firstFacet = Customizing skins
skinCss.definition1 = Skins in RichFaces can be customized on each of the three levels:
skinCss.item1 = Skin property files
skinCss.definition2 =  Application interfaces can be modified by altering the values of skin parameters in the skin itself. Edit the constant values defined in the skin.properties file to change the style of every component mapped to that skin property.
skinCss.item2 = Component stylesheets
skinCss.definition3 = Mappings and other style attributes listed in a component's ECSS file can be edited. Edit the ECSS file to change the styles of all components of that type.
skinCss.item3 = Custom components style classes
skinCss.definition4 = Individual components can use the styleClass attribute to use a unique style class. Add the new style class to the application CSS and reference it from an individual component with the styleClass attribute.
skinCss.item4 = Overwriting stylesheets in application
skinCss.definition5 = You can load custom stylesheets using <h:outputStylesheet> which rewrites of extends styles defined for style classes of components.
skinCss.info.title = Customizing skins by rewriting/extending component style classes
skinCss.info.explanation = If you want to extend/overwrite style sheet definitions with own stylesheets, make sure you place definitions to be rendered in right order of occurence.

skinCss.firstFacet.facet = Simple skinning example
skinCss.definition6 = Using any component, such as a panel, without specifying a styleClass will use the default skin parameters for that component.
skinCss.definition7 = When rendered for display, the panel consists of two HTML elements: a wrapper <div> element and a <div> element for the body of the panel. The wrapper element for a panel without a specified styleClass is rendered as follows:
skinCss.definition8 = To customize the panel appearance according to the three-level scheme, adjust the styles according to the following approach:
skinCss.item5 = Change the definitions for the generalBackgroundColor or panelBorderColor parameters in the skin. This will cause all panels in the application to change to the new settings.
skinCss.item6 = Redefine the rf-p class in the application CSS. This will also cause all panels in the application to change to the new settings, though the skin itself has not been altered. Any properties not mapped to skin parameters should be redefined in this way.
skinCss.item7 = Specify a different styleClass attribute to style the individual component. If a styleClass attribute is used, the specified style class is applied to the component, which could extend or override the default styles.
skinCss.definition9 = The customClass style is added to the CSS, and is applied to the component when it is rendered for display:

skinCss.secondFacet = Support for round corners
skinCss.definition10 = Support for round borders in your skins is available via the panelBorderRadius skin parameter. The value of this parameter maps to the CSS 3 border-radius property. This CSS 3 property is ignored in older browsers, and the skin gracefully degrades to square corners.
skinCss.definition11 = Units of the panelBorderRadius skin parameter must be either px (pixels). or % (a percentage).

skinCss.thirdFacet = ECSS files
skinCss.definition12 = RichFaces uses ECSS files to add extra functionality to the skinning process. ECSS files are CSS files which use Expression Language (EL) to connect styles with skin properties.
skinCss.secondFacet.facet = ECSS style mappings
skinCss.definition13 = The ECSS code for the <rich:panel> component contains styles for the panel and its body:
skinCss.definition14 = defines the panel styles:
skinCss.item8 = The background-color CSS property maps to the generalBackgroundColor skin parameter.
skinCss.item9 = The color CSS property maps to the panelBorderColor skin parameter.
skinCss.definition15 = defines the panel body styles:
skinCss.item10 = The font-family CSS property maps to the generalFamilyFont skin parameter.
skinCss.item11 = The font-size CSS property maps to the generalSizeFont skin parameter.
skinCss.item12 = The color CSS property maps to the generalTextColor skin parameter.

skinCss.fourthFacet = Skinning standard controls
skinCss.definition16 = Standard HTML controls used alongside RichFaces components are also themed to create a cohesive user interface.
skinCss.fourthFacet.firstFacet = Automatic skinning
skinCss.definition17 = The skinning style properties are automatically applied to controls based on their element names and attribute types. If the HTML elements are referenced in the standard skin stylesheets, the controls will be styled according to the mapped skin properties.
skinCss.definition18 = Standard HTML controls are skinned in this way by default. To override this behavior and prevent the RichFaces skins from being applied to the standard HTML controls, set the org.richfaces.enableControlSkinning context parameter in the web.xml configuration file to false:
skinCss.fourthFacet.secondFacet = Skinning with the rfs-ctn class
skinCss.definition19 = The skinning style properties can be determined through a separate CSS class. This method is not available by default, but is enabled through the org.richfaces.enableControlSkinningClasses context parameter in the web.xml configuration file:
skinCss.definition20 = When enabled, a stylesheet with predefined classes offers a special CSS class named rfs-ctn. Reference the rfs-ctn class from any container element (such as a <div> element) to skin all the standard HTML controls in the container.
skinCss.definition21 = Standard HTML controls can also be specifically defined in the CSS. Refer to the /core/impl/src/main/resources/META-INF/resources/skinning_both.ecss file in the richfaces-ui.jar package for examples of specially-defined CSS classes with skin parameters for HTML controls.

# ==============================================================================
# Templating facelets (skinCss.xhtml)
# ==============================================================================

templating.definition = The term Facelets refers to the view declaration language for JavaServer Faces technology. JavaServer Pages (JSP) technology, previously used as the presentation technology for JavaServer Faces,  does not support all the new features available in JavaServer Faces in the Java EE 6 platform. JSP technology is considered to be a deprecated presentation technology for JavaServer Faces. Facelets is a part of the JavaServer Faces specification and also the preferred presentation technology for building JavaServer Faces technology-based applications.
templating.component = The ui:component tag inserts a new UIComponent instance into the JSF component tree. Any components or content fragments outside this tag will be ignored by the Facelets view handler. Any components or content fragments within this tag will be added to the component tree as children of the UIComponent instance. See also ui:fragment.
templating.composition = The ui:composition tag is a templating tag that wraps content to be included in another Facelet. Any content outside of the ui:composition tag will be ignored by the Facelets view handler. Any content inside of the ui:composition tag will be included when another Facelets page includes the page containing this ui:composition tag. See also ui:include.
templating.debug = The ui:debug tag allows you to display helpful information about the JSF component tree and scoped variables in your browser when you test your JSF pages. The hotkey attribute specifies a key combination (CTRL + SHIFT + 0 is the default value) to display the popup window containing the information. The UI Debug tag can be enabled or disabled by setting the rendered attribute.
templating.decorate = The ui:decorate tag is a templating tag that decorates content included from another Facelet. Any content outside of the ui:decorate tag will be displayed by the Facelets view handler. Any content within the decorate tag will be passed to the associated template as parameters or simply ignored. You can use nested ui:define tags to pass named content to the associated template. See ui:insert for more information.
templating.define = The ui:define tag is a templating tag that defines named content to be inserted into a template. The name attribute value must match that of a ui:insert tag in the target template for the named content to be included.
templating.fragment = The ui:fragment tag inserts a new ui:Component instance into the JSF component tree. Any components or content fragments outside this tag will be included by the Facelets view handler. Any components or content fragments within this tag will be added to the component tree as children of this component instance. See also ui:component.
templating.include = The ui:include tag is a server-side include tag for Facelets. It simply includes the document pointed to by the "src" attribute as part of the current JSF page. The included document should use a component or composition tag to trim unnecessary markup, or it may simply contain a fragment of XHTML or XML to be included.
templating.insert = The ui:insert tag is a templating tag that declares a named content element to be defined by another Facelet. It can be used effectively with the ui:define tag to pass values between Facelets.
templating.param =  The ui:param tag is used to pass objects as named variables between Facelets. The name attribute of the UI Param tag should match the name attribute of a ui:define tag contained in a ui:composition or ui:decorate in the template page receiving the object. The UI Param tag can also be used to pass objects to another page by using the ui:include tag.
templating.repeat = The ui:repeat tag is used to iterate over a collection of objects exposed to the JSF page as a value-binding EL expression. It is intended as a replacement for the c:forEach tag from the JSTL Core tag library.
templating.remove = The ui:remove tag is used to specify tags or blocks of content that should be removed from your page by the Facelets view handler at compile time. This tag has no attributes. Note that the Facelets compilation process is much faster than the JSP compilation process because no Java bytecode is actually generated and compiled behind the scenes when you  visit your page. The ui:remove tag is used to specify tags or blocks of content that should be removed from your page by the Facelets view handler at compile time. This tag has no attributes.

# ==============================================================================
# File Upload (fileUpload.xhtml)
# ==============================================================================

fileUpload.message = Only JPG, GIF, PNG and BMP files are accepted
fileUpload.panel.title = Uploaded Files Info
fileUpload.noFiles = No files currently uploaded
fileUpload.fileName = File Name:
fileUpload.fileLength = File Length (bytes):
fileUpload.clearUploadedData = Clear Uploaded Data
fileUpload.viewManagedBean = View FileUploadBean.java
fileUpload.viewJSF = View source
fileUpload.viewSupportFile = View UploadedImage.java

# ==============================================================================
# Remote paging Grid (userGrid.xhtml)
# ==============================================================================

pagingGrid.title = Remote Paging Grid Sample
pagingGrid.tableTitle = Users Paging Grid
pagingGrid.resetSorting = Reset Sorting
pagingGrid.tooltip.edit = Edit
pagingGrid.tooltip.delete = Delete
pagingGrid.editDetail = Edit User Details